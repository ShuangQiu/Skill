/**** copyleft ************************************
* Authors : Edouard BECETHOILLE. IPNL (IN2P3-CNRS / UCBL ) MICRHAU *
* Version : 0.9.2   sept 2011                       *
* History :  pour s'ajuster aux lib std IBM    *
***************************************************/

; load("padRing.il")
skillDir="~/../ebecheto/Skill"
when(not(rexMatchList(skillDir getSkillPath())) setSkillPath(cons(skillDir getSkillPath())))
; sch and symbol createBox functions
load("padRing.proc.il")
load("padRing.sch.il")

procedure(createPadRing( l_pins @optional (spaceL 5) (spaceH 5) (libname getEditRep()~>libName) (cellname getEditRep()~>cellName)  @rest rest)
let( (cv nPad nMiss cList rList tmp tmpList tmpLib tLib sx sy pinBox epinBox textBox etextBox x0 x1 y0 y1 step  norient lay l_mapPins  padLength cornerH cornerW pinList X Y inst METAL sign termSkip loop XP inter opt I padLib padCap IO fill price fillFirst fillLast VDD GND shortList lr interLib comp compLib layBox fillPar fillOffset)
; nb of pads, missingPads, currentListElement,  remainingList, step in x, step in y
(setq lay "layout")  I=0

;; @rest other default parameter 
if(lr=assoc("toSkip" rest) then    termSkip=eval(cadr(lr)) else  termSkip="PAD")
if(lr=assoc("fillLast" rest) then  fillLast=eval(cadr(lr)) else  fillLast=nil)
if(lr=assoc("fillFirst" rest) then fillFirst=eval(cadr(lr)) else fillFirst=nil)
if(lr=assoc("price" rest) then     price=eval(cadr(lr)) else price=650)
if(lr=assoc("fill"  rest) then     fill=eval(cadr(lr)) interLib=caddr(lr) fillPar=nth(3 lr) else fill="PERI_SPACER_100_P")
if(lr=assoc("complete"  rest) then comp=eval(cadr(lr)) compLib=caddr(lr) else comp="PERI_SPACER_100_P")
if(lr=assoc("IO" rest) then        IO=   eval(cadr(lr)) printf("SET IO %s\n" IO)  else IO="APRIOP")
if(lr=assoc("padCap" rest) then  padCap=eval(cadr(lr)) else  padCap="CORNERP")
if(lr=assoc("padLib" rest) then  padLib=cadr(lr) else  padLib=ddGetLibList()~>name) ;
if(lr=assoc("VDD" rest) then  VDD=eval(cadr(lr)) else  VDD="VDD") ; utilise par netSetPatch par defaut : "VDD" et "GND"
if(lr=assoc("GND" rest) then  GND=eval(cadr(lr)) else  GND="GND") ;
if(lr=assoc("shortList" rest) then  shortList=eval(cadr(lr)) else shortList='("APRIOP" "APRIOP_3B" )) ;shortTermList='("APRIOP" "APRIOP_3B" )
if(lr=assoc("metal" rest) then  METAL=eval(cadr(lr)) else  METAL="MET1" when(rexMatchp("APRIO1V8_00" IO) METAL="M3"))
if(lr=assoc('fillOffset rest) then printf("FILLOFFSET %L\n" lr) fillOffset=cadr(lr) else fillOffset=nil)
; since string could be avoid by using quote. let's avoid it in next version of script

; if(lr=assoc("padLib" rest) padLib=cadr(lr) padLib='("IOLIB_4M" "IOLIB_ANA_4M")) ;ddGetLibList()


printf("\n**** : %L" rest)
printf("\n**** : %L\n" l_pins) printf("Generate Layout in %L %L with %L %L %L LIB:%L\n" libname cellname IO fill padCap padLib)
nPad = length(l_pins)/4 ; (/4!=/4.0)
when( nPad*4 != length(l_pins)
	nPad = nPad+1
	nMiss = nPad*4 - length(l_pins)
	for( i 1 nMiss  l_pins=append( l_pins list(list(comp comp)))) ;<== complete avec des spacer; mettre dimension 70
	;;for( i 0 nMiss-1  l_pins=append( l_pins list(list("gnd" GND)))) ;<==complete avec des gnd!
	); fin du when

unless( ddGetObj(libname) error("Couldn't open library %L. Please open any new layout.\n" libname)  )
cv = dbOpenCellViewByType( libname cellname "layout"   "maskLayout" "w")
; cv = dbOpenCellViewByType( "Ed_CMOS8" "RINGx" "layout"   "maskLayout" )
cvp = dbOpenCellViewByType(libname cellname "layout_p" "maskLayout" "w")


;; Creation  d'un AST (Abstract Syntax Tree) de type list(list("padInstName" "padCell" "padLib") list("padInstName2" "padCell2" "padLib2") ...)
; printf("PADLIST: %L \n" padLib)

ioLib=whereExistCell(IO padLib)      when(length(ioLib)>=2    printf("WARNING %L exist in Library:%L-Taking %L\n" IO ioLib car(ioLib)))       ioLib=car(ioLib)	    
capLib=whereExistCell(padCap padLib) when(length(capLib)>=2   printf("WARNING %L exist in Library:%L-Taking %L\n" padCap capLib car(capLib)))     capLib=car(capLib)	    
unless(interLib interLib=whereExistCell(fill padLib) when(length(interLib)>=2 printf("WARNING %L exist in Library:%L-Taking %L\n" fill interLib car(interLib))) interLib=car(interLib))
unless(compLib   compLib=whereExistCell(comp padLib) when(length(compLib )>=2 printf("WARNING %L exist in Library:%L-Taking %L\n" fill compLib  car(compLib )))  compLib=car(compLib))
XP=0.5*if(I=caadr(getMaxPointsLayer((dbOpenCellViewByType ioLib IO lay) METAL)) I 100);spacePad/2
;; XP=0.5*if(I=caadr(getMaxPointsLayer((dbOpenCellViewByType interLib fill lay) METAL)) I 100);spacePad/2
printf("<_> Taking XP=%g spacing because getMaxPointsLayer((dbOpenCellViewByType %L %L %L) %L ) \n" XP ioLib IO lay METAL)

map1List = foreach( mapcar x l_pins if(!listp(x) then append(list(x) list(IO ioLib)) else x)) ;; pour les elements seul, "in", rajoute ("in" "PAD_IO" "PAD_IO_lib")
map2List = foreach( mapcar x map1List if(length(x)==1 then append(x list(IO ioLib)) else x)) ;; pour les elements seul, ("in"), rajoute ("in" "PAD_IO" "PAD_IO_lib")

rList = foreach( mapcar x map2List
if(length(x)==2 then
tmpLib=whereExistCell(cadr(x) padLib )
when(not(tmpLib) if(tLib=whereExistCell(cadr(x)) then printf("%L does not exist in %L but exist in cds.lib:%L. Please add it to the sensivity list.\n" cadr(x) padLib tLib)
else printf("%L does not exist in cds.lib?!\n" cadr(x))))
when(length(tmpLib)>=2 printf("WARNING %L exist in multiple Library:%L Taking %L.\n" cadr(x) tmpLib car(tmpLib)) tmpLib=car(tmpLib))
when(type(tmpLib)=='list tmpLib=car(tmpLib))
if(tmpLib then append(x list(tmpLib))  else x_=append(list(x) list("TOCHANGE"))  )
else x));; pour les elements double, '("vdede" "AVDD3ALLP_3B"), rajoute la lib ("vdede" "AVDD3ALLP_3B" "IOLIB_ANA_3B_4M")

;;** Sch Sym creation du symbol et du schematic associe :
;procedure(createSch( l_pins @optional (library getEditRep()~>libName ) (cell getEditRep()~>cellName) (padLib "PAD_cell_S35D4") (padCap "PAD_capa") )
pinList=createSch(rList libname cellname padCap padLib); getEditRep()~>libName getEditRep()~>cellName padLib padCap)
; printf("FROM_SCH_pinList= %L\n" pinList)
; printf("LENGTH:%L?=%L\n" length(rList) length(pinList))
tmpList = rList

padLength=bBoxWidth(getMaxPointsLayer((dbOpenCellViewByType ioLib IO "layout") METAL ))
; (setq padLength 100) ; MET1 abutment length for a PAD

; printf("(dbOpenCellViewByType %L %L \"layout\")\n" capLib padCap)
;     getMaxPointsLayer((dbOpenCellViewByType "short_io" "SIOCORNER45" "layout") "LY" )
;     getMaxPointsLayer((dbOpenCellViewByType "short_io" "SIOCORNER45" "layout") "MG" )
capBBox=getMaxPointsLayer((dbOpenCellViewByType capLib padCap "layout") METAL )
cornerH=bBoxWidth(capBBox)
cornerW=bBoxHeight(capBBox)
;; cornerH=caadr(capBBox)
;; cornerW=cadadr(capBBox)

(setq sizeL 2*bBoxWidth(capBBox)+nPad*padLength+(nPad-1)*spaceL)  ; total Length  ;for text label information
(setq sizeH 2*bBoxHeight(capBBox)+nPad*padLength+(nPad-1)*spaceH)  ; total Height
bBox = list(sizeL sizeH)

tmp=nil B=nil R=nil T=nil L=nil ;  coupe la liste en quatre suivant : Bottom Right Top Left
for(i 1 nPad tmp=tconc(tmp car(tmpList)) tmpList=cdr(tmpList)) B=car(tmp) tmp=nil
for(i 1 nPad tmp=tconc(tmp car(tmpList)) tmpList=cdr(tmpList)) R=car(tmp) tmp=nil
for(i 1 nPad tmp=tconc(tmp car(tmpList)) tmpList=cdr(tmpList)) T=car(tmp) tmp=nil
for(i 1 nPad tmp=tconc(tmp car(tmpList)) tmpList=cdr(tmpList)) L=car(tmp) tmp=nil

dX=0 X=0 Y=0 sign=1
norient=-1;         5  cornerW
(foreach BRTL '( ( B) ( R) ( T) ( L) );; re-cree une liste
;(setq RH car(BRTL))
;(setq step eval(car(BRTL))) ;(setq dX eval(cadr(BRTL)))
norient++
rot=sprintf(nil "R%d" 90*norient)
(setq rListHL eval(car(BRTL)))
; when(norient==1||norient==3 (setq rListHL reverse(rListHL)))
; when(norient>=2 sign=-1)
sign=(-1)**mod(norient/2 2)

inst=(dbOpenCellViewByType capLib padCap lay) 
layBox=getMaxPointsLayer(inst METAL)
; dX=caar(layBox);<= ajuste le debut avant de poser
; printf("CORNER:%L=>" X:Y)
; X=X+sign*dX*mod(norient+1-1 2) Y=Y+sign*dX*mod(norient-1   2)
; printf("%L,dX=%f orient=%d. layBox=%L\n" X:Y dX norient layBox)
(dbCreateInst cv inst nil X:Y rot)
dX=caadr(layBox);=> ajuste la fin apres la pose
; dX=bBoxWidth(getMaxPointsLayer(inst METAL))
X=X+sign*dX*mod(norient+1 2) Y=Y+sign*dX*mod(norient   2)

if(rexMatchp("_3B$" fill) opt="_3B" opt="")
when(rexMatchp("TECH_H18"  techGetTechFile(ddGetObj(libname))~>libName) opt="H18")
;printf("FILL %L %L\n" fill opt)
if(mod(norient 2)==0 then inter=biggerPeri(spaceH opt) else inter=biggerPeri(spaceL opt)) ;/!\ techno dependant. TOCHANGE
;printf("INTER%L\n" list(spaceH spaceL inter mod(norient 2)) )
when(not( (dbOpenCellViewByType interLib inter lay)) inter=fill) ;; todo : adapt when inter and fill not in the same lib goto :interLib=whereExistCell(fill padLib...)

loop=0
(foreach instRef rListHL ;; MAIN LOOP
loop++
instName =car(instRef)
instCell=cadr(instRef)
instLib=caddr(instRef)

; printf("INTER%L\n" instRef )
when(loop!=1||fillFirst
; printf("INTER:%L\n"  list(interLib inter lay))
; getMaxPointsLayer((dbOpenCellViewByType "Ed_CMOS8" "SIOFILL_10" "layout") "LY" )
inst=(dbOpenCellViewByType interLib inter lay) 
layBox=getMaxPointsLayer(inst METAL)
dX=caar(layBox)
X=X+sign*dX*mod(norient+1 2) Y=Y+sign*dX*mod(norient   2)
;(dbCreateInst cv inst nil X:Y rot)
; printf("INTER %L\n" inst~>??)
; printf("INTER %L\n" fillPar)
; printf("fillPar:%L %L %L \n" fillPar spaceL norient)
when(fillPar if(mod(norient 2)==0 fPar=fillPar fPar=list(list(caar(fillPar) nth(1 car(fillPar)) spaceL))))
;^= very specific to the context TOCHANGE
; printf("   fPar:%L\n" fPar)
inst=dbCreateParamInst(cv inst nil X:Y rot 1 fPar);<= identique a dbCreateInst si fillPar=nil
;  dbCreateParamInst(cv inst X:Y rot 1 list(list("sx" "float" xs) list("sy" "float" ys))) 
; if(fillPar dbCreateParamInst(cv inst X:Y rot 1 fillPar) ...) 
; dbCreateParamInst(cv inst -10:-10 "R0" 1 list(list("sx" "float" 1) list("sy" "float" 10)))
dX=caadr(getMaxPointsLayer(inst~>master METAL))
;printf("MOVE INTER %g _%L_MET%L\n" dX X:Y METAL)
X=X+sign*dX*mod(norient+1 2) Y=Y+sign*dX*mod(norient   2)
)

;; INSERTION PAD ROW1 ;;
inst=(dbOpenCellViewByType instLib instCell lay)
layBox=getMaxPointsLayer(inst METAL)
dX=caadr(layBox)
d_inst=(dbCreateInst cv inst nil X:Y rot) ;ie. "PAD_IO" "RO" ou R90
dX=caadr(layBox)
; dX=bBoxWidth(getMaxPointsLayer(inst METAL))
; printf("%f=getOrientLayer%L\n" dX list( inst METAL norient))

 ;; INSERTION text ROW1 ;;
dbCreateLabel(cv "text"  X+XP*(-1)**mod((norient+0)/2 2):Y+XP*(-1)**mod((norient+3)/2 2) instName "centerRight" sprintf(nil "R%d" mod(90*(norient+1) 360)) "stick" 40)
;printf("XY: %L %L \n" mod((norient+0)/2 2) mod((norient+1)/2 2) )

 ;; INSERTION pins+label ROW1 ;;
termName=instName
foreach(termLabel termPoints=(dbOpenCellViewByType instLib instCell "symbol")~>sigNames;=> ("PAD" "EN" "Y" "A")
termName=instName
dbPin=setof(term d_inst~>master~>terminals term~>name==termLabel);=>(db:0xc1c2c3)
foreach(sPin dbPin~>pins foreach(sfig sPin~>fig
sbBox=dbTransformBBox(sfig~>bBox d_inst~>transform)
when(and( termLabel!=termSkip length(termPoints)!=1 not(member(instCell shortList) )) termName=sprintf(nil "%s_%s" termName termLabel))
leCreatePin(  cv sfig~>lpp "rectangle" sbBox termName "inputOutput" list("left" "right") )
dbCreateLabel(cv sfig~>lpp centerBox(sbBox)  termName "centerCenter" "R0" "roman" 3)
)))

when(pBox=getMaxPointsLayer(inst "PAD" ) pBox=dbTransformBBox(pBox d_inst~>transform)           ; for additionnal
leCreatePin(  cvp '("PIN" "pad") "rectangle" pBox termName "inputOutput" list("left" "right") ) ; pin for TOP cell
dbCreateLabel(cvp '("PIN" "pad") centerBox(pBox)  termName "centerCenter" "R0" "roman" 10))     ;

X=X+sign*dX*mod(norient+1 2) Y=Y+sign*dX*mod(norient 2)

); for nPad (elements in instanceList)
;ending spacer before corner

when(fillLast
inst=(dbOpenCellViewByType interLib inter lay) 
layBox=getMaxPointsLayer(inst METAL)
dX=caar(layBox)
X=X+sign*dX*mod(norient+1 2) Y=Y+sign*dX*mod(norient 2)
;(dbCreateInst cv inst nil X:Y rot)
inst=dbCreateParamInst(cv inst nil X:Y rot 1 fPar);<= identique a dbCreateInst si fillPar=nil
;dX=caadr(layBox)
dX=caadr(getMaxPointsLayer(inst~>master METAL))
X=X+sign*dX*mod(norient+1 2) Y=Y+sign*dX*mod(norient 2)
)

if(norient==1||norient==3 dX=cornerH dX=cornerW)
X=X+sign*dX*mod(norient+1 2) Y=Y+sign*dX*mod(norient 2)

);foreach orient 0;180 puis 90;270

;dbCreateLabel(cv "text"  (0:0) sprintf(nil "bBox (L, H) : %L. \nArea : %L mm2" bBox car(bBox)*cadr(bBox)/1000000.0) "centerRight" "R0" "stick" 40)
dbCreateLabel(cv "text"  (cornerW:0) sprintf(nil "bBox (L, H) :\n%L\nArea :\n%L mm2" bBox car(bBox)*cadr(bBox)/1000000.0) "upperRight" "R0" "stick" 40)
printf("bBox(L,H):%L price: %L " bBox price*(240+car(bBox))*(240+cadr(bBox))*1.0u)  printf(" Pad:%L nMiss %L\n" nPad*4 nMiss)

assuraPinPatch(cv)
printf("assuraPinPatch()\n")
printf("netSetPatch()\n")
printf("netSetPatch( geGetWindowCellView() %L %L )\n"  "gnd!" "vdd!")
netSetPatch( geGetWindowCellView() GND VDD)
printf("X:Y=%L\n" X:Y)

miscPatch(cv)
dbSave(cv) dbClose(cv) dbSave(cvp) dbClose(cvp)
l_pins);let
);proc

;; ________________________________________________________________________________ ;;


nbOfPin = 52
result ='() for(i 1 nbOfPin result=tconc(result sprintf(nil "pad_%d" i))) result=car(result)


; USAGE :
; padLib='("IOLIB_4M" "IOLIB_ANA_4M" "IOLIB_3B_4M" "IOLIB_ANA_3B_4M")
padLib='("short_io" "cmrf8sf" "cmos8rf" )

ibm_pins='(
( "VDD" "SIOVDD") ( "VDD" "SIOVDD") ( "VDD" "SIOVDD") ( "VDD" "SIOVDD")
"O1" "O2" "O3" "O4"
("GND" "SIOGND") ("GND" "SIOGND") ("GND" "SIOGND")
("GND" "SIOGND")
"I3"
("Idigital4" "SIOB04_B")
"I2"
;("I1")
)

h18_pins='(
( "VDD" "VDDPAD1V8ALL") ( "VDD" "VDDPAD1V8ALL") ( "VDD" "VDDPAD1V8ALL") ( "VDD" "VDDPAD1V8ALL")
"O1" "O2" "O3" "O4"
("GND" "GNDPAD1V8") ("GND" "GNDPAD1V8") ("GND" "GNDPAD1V8")
("GND" "GNDPAD1V8")
"I3"
("Idigital4" "IOPAD1V8_3")
"I2"
;("I1")
)

l_pins='(
( "VDD" "AVDD3ALLP") ( "VDD" "AVDD3ALLP") ( "VDD" "AVDD3ALLP") ( "VDD" "AVDD3ALLP")
"O1" "O2" "O3" "O4"
("GND" "AGND3ALLP") ("GND" "AGND3ALLP") ("GND" "AGND3ALLP")
("GND" "AGND3ALLP")
"I3"
("Idigital4" "BBCU4P")
"I2"
;("I1")
)

;; foreach( x l_pins  when(listp(x)&&car(x)=="GND" setcdr(x '("AVSUBP_3B")) )   x)
;; foreach( x l_pins  when(listp(x)&&car(x)=="VDD" setcdr(x '("AVDD3ALLP_3B")) )   x)
;; foreach( x l_pins  when(listp(x)&&cadr(x)=="APRIOP" setcdr(x '("APRIOP_3B")) )   x)
;; foreach( x l_pins  when(listp(x)&&cadr(x)=="BBCU4P" setcdr(x '("BBCU4P_3B")) )   x)



; createPadRing( ibm_pins 10 50 "Ed_CMOS8" "RINGx" '("IO" "SIOWIRE_ESD") '("fill" "SIOFILL_10") '("padCap" "SIOCORNER") list("padLib" '("short_io" "cmrf8sf")) '("metal" "M3") )
createPadRing( ibm_pins 10 50 "Ed_CMOS8" "RINGx" '("IO" "SIOWIRE_ESD") '("fill" "SIOFILL_sx" "Ed_CMOS8" (("sx" "float" 50)) ) '("complete" "SHORT_IO_BREAKGND_CELL_8MA_44" "short_io") '("padCap" "SIOCORNER45")  '("metal" "MG") '("fillFirst" t) '("fillLast" t) '(fillOffset 0.2) )
;createPadRing( l_pins 10 50 "Ed" "RINGx" '("IO" "APRIOP") '("fill" "PERI_SPACER_100_P") '("padCap" "CORNERP")  list("padLib" padLib))
;createPadRing( l_pins 10 50 "Ed" "RINGx")

;; pn=geGetWindowCellView()~>terminals~>name
;; foreach(mapcar p pn cond( (rexMatchp("vdd" p) list(p "AVDD3ALLP")) (rexMatchp("gnd" p) list(p "AGND3ALLP")) (t p) ) )


;; file=strcat(pwd() "/cds.lib")
;; myPort=infile(file) homeLib='() 
;; ;PWD=pwd()
;; PWD="/home/validmgr/ebecheto/Work/IC6"
;; while(gets(nextLine myPort)
;; ; printf("%s\n" nextLine)
;; when(rexMatchp(PWD nextLine) homeLib=append(homeLib list(cadr(parseString(nextLine " ")))))
;; ) homeLib LIB=car(homeLib)

;LIB="Ed_IC6"
;; ddLib=ddGetObj(LIB)
; techGetTechFile(ddLib)~>??
; techGetTechFile(ddLib)~>libName ;=> "TECH_C35B4" || "TECH_H18A7" 
; techGetTechFile(ddGetObj(libname))~>libName

;; rx=0 CELL=sprintf(nil "%s_%d" "RING" rx)
;; while(member("schematic" dbAllCellViews(ddLib CELL)) rx=rx+1 CELL=sprintf(nil "%s_%d" "RING" rx))


;; IOCELL="APRIOP"
;; PERICELL="PERI_SPACER_100_P"
;; CORNERCELL="CORNERP"

;; when(rexMatchp("TECH_H18" car(ddLib~>prop)~>value)
;; IOCELL="APRIO1V8_00"
;; PERICELL="PERI_SPACER_50"
;; CORNERCELL="CORNER"
;; METAL="M3"
;; l_pins=h18_pins
;; )

;; when(ddLib
;; createPadRing(l_pins 5 50 LIB CELL '("IO" IOCELL) '("fill" PERICELL) '("padCap" CORNERCELL) '("fillFirst" nil) '("fillLast" nil) '("GND" "gnd!") '("VDD" "vdd!"))
;; )

;; l_pins=
;; '(("VDD" "AVDD3ALLP_3B") 
;;     ("VDD" "AVDD3ALLP_3B") 
;;     ("VDD" "AVDD3ALLP_3B") 
;;     ("VDD" "AVDD3ALLP_3B") "O1"
;;     "O2" "O3" "O4" 
;;     ("GND" "AVSUBP_3B") 
;;     ("GND" "AVSUBP_3B")
;;     ("GND" "AVSUBP_3B") 
;;     ("GND" "AVSUBP_3B") "I3" 
;;     ("Idigital4" "BBCU4P_3B") "I2"
;; )

